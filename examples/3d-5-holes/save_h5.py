import numpy
from firedrake import *
from fir3dab import vtktools
import os

"""
This script takes the pvd files generated by make_vtu.py and interpolates them to
the finer mesh and correct function spaces. Run this script with the same number of cores
you want to run the grid-sequencing with. These saved .xml.gz files are then used as initial guesses.

"""

# Necessary replication of code to generate the correct mesh.
comm = COMM_WORLD
nref = 1

def before(dm, i):
    for p in range(*dm.getHeightStratum(1)):
        dm.setLabelValue("prolongation", p, i+1)

def after(dm, i):
    for p in range(*dm.getHeightStratum(1)):
        dm.setLabelValue("prolongation", p, i+2)

distribution_parameters = {"partition": True, "overlap_type": (DistributedMeshOverlapType.VERTEX, 2)}
mesh = Mesh("mesh-5-holes.msh", comm=comm, distribution_parameters = distribution_parameters)
mh = MeshHierarchy(mesh, nref, reorder=True, callbacks=(before,after))
mesh = mh[1]

# Now use integral dofs for BDM discretization
Ve = FiniteElement("BDM", mesh.ufl_cell(), 1, variant="integral") # velocity
Pe = FiniteElement("DG", mesh.ufl_cell(), 0) # pressure
Ce = FiniteElement("DG", mesh.ufl_cell(), 0) # control
Re = FiniteElement("R",  mesh.ufl_cell(), 0) # reals
Ze = MixedElement([Ce, Ve, Pe, Re])
Z  = FunctionSpace(mesh, Ze)
z  = Function(Z)

for branch in range(14):
    # Do vtktools trickery to interpolate the solutions onto the fine mesh for grid-sequencing
    # with any number of cores.

    W = VectorFunctionSpace(mesh, "DG", 0)
    X = interpolate(SpatialCoordinate(mesh), W)
    vtu = vtktools.vtu("pvd/rho-%s_0.pvtu"%branch)
    reader = lambda X: vtu.ProbeData(numpy.c_[X, numpy.zeros(X.shape[0])], "Solution").reshape((-1,))
    V = FunctionSpace(mesh, "DG", 0)
    rho = Function(V)
    rho.dat.data[:] = reader(X.dat.data_ro)
    z.split()[0].assign(rho)

    W = VectorFunctionSpace(mesh, "DG", 1, dim=3)
    X = interpolate(SpatialCoordinate(mesh), W)
    vtu = vtktools.vtu("pvd/u-%s_0.pvtu"%branch)
    reader = lambda X: vtu.ProbeData(numpy.c_[X, numpy.zeros(X.shape[0])], "Solution")[:,:]
    V = VectorFunctionSpace(mesh, "DG", 1, dim=3)
    u = Function(V)
    u.dat.data[:] = reader(X.dat.data_ro)
    z.split()[1].interpolate(u)

    W = VectorFunctionSpace(mesh, "DG", 0)
    X = interpolate(SpatialCoordinate(mesh), W)
    vtu = vtktools.vtu("pvd/p-%s_0.pvtu"%branch)
    reader = lambda X: vtu.ProbeData(numpy.c_[X, numpy.zeros(X.shape[0])], "Solution").reshape((-1,))
    V = FunctionSpace(mesh, "DG", 0)
    p = Function(V)
    p.dat.data[:] = reader(X.dat.data_ro)
    z.split()[2].assign(p)

    # Value of volume Lagrange multiplier saved manually.
    if branch == 0:
        z.split()[3].assign(Constant(476.09075498))
    elif branch == 1:
        z.split()[3].assign(Constant(478.11631629))
    elif branch == 2:
        z.split()[3].assign(Constant(513.44103762))
    elif branch == 3:
        z.split()[3].assign(Constant(517.13582201))
    elif branch == 4:
        z.split()[3].assign(Constant(521.3451903))
    elif branch == 5:
        z.split()[3].assign(Constant(514.63223636))
    elif branch == 6:
        z.split()[3].assign(Constant(518.32164443))
    elif branch == 7:
        z.split()[3].assign(Constant(517.57092066))
    elif branch == 8:
        z.split()[3].assign(Constant(513.82879132))
    elif branch == 9:
        z.split()[3].assign(Constant(510.63159027))
    elif branch == 10:
        z.split()[3].assign(Constant(516.89061732))
    elif branch == 11:
        z.split()[3].assign(Constant(506.80665723))
    elif branch == 12:
        z.split()[3].assign(Constant(514.92335058))
    elif branch == 13:
        z.split()[3].assign(Constant(515.20266854))

    # Save fine-mesh initial guess as a .xml.gz file
    h5 = HDF5File("initial-guess/%s.xml.gz"%branch, "w", comm=comm)
    h5.write(z, "/guess")
    del h5
