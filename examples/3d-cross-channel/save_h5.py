import numpy
from firedrake import *
from fir3dab import vtktools
import os

"""
This script takes the pvd files generated by make_vtu.py and interpolates them to
the finer mesh and correct function spaces. Run this script with the same number of cores
you want to run the grid-sequencing with. These saved .xml.gz files are then used as initial guesses.
"""

comm = COMM_WORLD
width = 1. # aspect ratio
N = 20  # mesh resolution
nref = 1

# Setup mesh.
def before(dm, i):
    for p in range(*dm.getHeightStratum(1)):
        dm.setLabelValue("prolongation", p, i+1)

def after(dm, i):
    for p in range(*dm.getHeightStratum(1)):
        dm.setLabelValue("prolongation", p, i+2)

distribution_parameters = {"partition": True, "overlap_type": (DistributedMeshOverlapType.VERTEX, 2)}
mesh = BoxMesh(N, N, N, width, 1.0, 1.0, distribution_parameters = distribution_parameters, comm=comm)
mh = MeshHierarchy(mesh, nref, reorder=True, callbacks=(before,after))
mesh = mh[1]

# Now use integral dofs for BDM discretization
Ve = FiniteElement("BDM", mesh.ufl_cell(), 1, variant="integral") # velocity
Pe = FiniteElement("DG", mesh.ufl_cell(), 0) # pressure
Ce = FiniteElement("DG", mesh.ufl_cell(), 0) # control
Re = FiniteElement("R",  mesh.ufl_cell(), 0) # reals
Ze = MixedElement([Ce, Ve, Pe, Re])
Z  = FunctionSpace(mesh, Ze)
z  = Function(Z)

for branch in range(3):
    # Do vtktools trickery to interpolate the solutions onto the fine mesh for grid-sequencing
    # with any number of cores.

    W = VectorFunctionSpace(mesh, "DG", 0)
    X = interpolate(SpatialCoordinate(mesh), W)
    vtu = vtktools.vtu("pvd/rho-%s_0.pvtu"%branch)
    reader = lambda X: vtu.ProbeData(numpy.c_[X, numpy.zeros(X.shape[0])], "Solution").reshape((-1,))
    V = FunctionSpace(mesh, "DG", 0)
    rho = Function(V)
    rho.dat.data[:] = reader(X.dat.data_ro)
    z.split()[0].assign(rho)

    W = VectorFunctionSpace(mesh, "DG", 1, dim=3)
    X = interpolate(SpatialCoordinate(mesh), W)
    vtu = vtktools.vtu("pvd/u-%s_0.pvtu"%branch)
    reader = lambda X: vtu.ProbeData(numpy.c_[X, numpy.zeros(X.shape[0])], "Solution")[:,:]
    V = VectorFunctionSpace(mesh, "DG", 1, dim=3)
    u = Function(V)
    u.dat.data[:] = reader(X.dat.data_ro)
    z.split()[1].interpolate(u)

    W = VectorFunctionSpace(mesh, "DG", 0)
    X = interpolate(SpatialCoordinate(mesh), W)
    vtu = vtktools.vtu("pvd/p-%s_0.pvtu"%branch)
    reader = lambda X: vtu.ProbeData(numpy.c_[X, numpy.zeros(X.shape[0])], "Solution").reshape((-1,))
    V = FunctionSpace(mesh, "DG", 0)
    p = Function(V)
    p.dat.data[:] = reader(X.dat.data_ro)
    z.split()[2].assign(p)

    # Value of volume Lagrange multiplier saved manually.
    if branch == 0:
        z.split()[3].assign(Constant(285.77096408))
    elif branch == 1:
        z.split()[3].assign(Constant(290.46921816))
    elif branch == 2:
        z.split()[3].assign(Constant(274.16518368))

    h5 = HDF5File("initial-guess/%s.xml.gz"%branch, "w", comm=comm)
    h5.write(z, "/guess")
    del h5
